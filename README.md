# 「IslandFlight」ポートフォリオ
## 川原電子ビジネス専門学校　ゲームクリエイター科２年
## 氏名：高橋 拓之

## 1.作品概要
- タイトル
  - IslandFlight
- 学校
  - 川原電子ビジネス専門学校
- 制作人数
  - 1人
- 対応ハード
  - PC Windows11
- 使用言語
  - C++
  - HLSL
- 開発環境
  - エンジン
    - 学校内製の簡易エンジン（DirectX12）
  - プログラム
    -  VisualStudio2026
  - GitHubリンク
    - <a href="https://github.com/takahasihiroyuki/Island-Flight" target="_blank"> https://github.com/takahasihiroyuki/Island-Flight</a>
## 2.ゲーム内容
時間内にたくさんコインを集めよう！
![alt text](<スクリーンショット (3)-1.png>)
## 3.技術紹介
### 3.1 飛行機の物理挙動の実装
#### 3.1.1 飛行機の挙動の実装アプローチ

今回の作品では、飛行機という題材を
単なる数値操作として扱うのではなく、
どのような力の関係によって挙動が生まれているのかを
自分の中でしっかり理解したいと考えました。

そのため、揚力・抗力・モーメントを用いた
物理モデルを採用しています。

#### 3.1.2  翼を単位とした物理モデル
本作では、機体全体に一つの力を与えるのではなく、右主翼・左主翼・水平尾翼・垂直尾翼といった各翼が、
それぞれ独立して力を発生させています。  
翼ごとに果たす役割（回転）は異なりますが、
本作では力の計算に用いる基本的な処理は共通としており、
各翼は同一のクラスのインスタンスとして実装しています。  
この構成により、翼を追加する場合も、
翼のインスタンスを一つ追加するだけで対応できます。

#### 3.1.3 力の計算
実際に機体に作用する各力をどのように計算しているかについて説明します。  
基本的に力はすべて三次元のベクトルとして扱っています。
考慮している力は、
重力、推力（プロペラによる前進力）、
揚力（翼を上方向に押し上げる力）、
抗力（進行方向と逆向きに作用する力）の四つです。  
揚力と抗力はそれぞれの翼で計算し、四つの翼の力を合成しています。  
そこに推力と重力を加えることで、
機体全体に作用する合力を求めています。  

#### 3.1.4 移動の計算
ひとつ前で計算した力をもとに、機体の位置を更新します。
流れとしては、力 → 加速度 → 速度 → 位置の流れです。  
まず、力から加速度に変換します、具体的には質量を割るだけです。  
（力は加速度と比例関係で今の実装では質量はほとんど意味を持っていないですが、機体重量の違いなどをパラメーターとして考慮したい時が来るかもしれないので念のため割り算しています）

そのフレームの速度を求めるために、そのフレームの加速度（つまり加速度×1フレームの時間）を毎フレーム蓄積させます。つまり積分です。  
さらに速度を積分し、次のポジションを求めています。
これを毎フレーム繰り返します。

#### 3.1.5 回転の計算
続いて、機体の回転の計算について説明します。
本作では、各翼で計算したモーメントを合成し、
機体全体に作用するモーメントを求めています。
##### モーメントについて

回転の計算を行う前に、
本作で用いているモーメントについて簡単に説明します。

モーメントは三次元のベクトルで、
ベクトルの大きさは回転の強さを、
向きは回転軸の向きを表します。

本作では、
機体の重心から力の作用点へのベクトルと、
その力との外積を用いてモーメントを計算しています。

##### 角速度と姿勢の更新
移動の計算と同様に、
まずモーメントから角加速度を計算し、
角加速度を積分することで角速度を求めます。
さらに、この角速度を積分することで、
機体の姿勢を毎フレーム更新しています。

#### 3.1.6 デバッグ方法
![alt text](<Game.exe 2025.12.26 - 11.15.59.01.gif>)  
本作では、
力やモーメントといった物理量を扱っているため、
数値だけを追っていても挙動の原因を把握しにくい場面が多くありました。 
しかも、本作では、
右主翼・左主翼・水平尾翼・垂直尾翼の
四つの翼それぞれで力とモーメントを計算しています。
さらに、モーメントは力の作用位置にも影響を受けるため、
挙動がおかしくなった場合でも、

どの翼が原因なのか

どの力やモーメントが問題なのか

を、
機体の姿勢や数値ログだけから直感的に判断することは困難でした。  
そこで、
本作では物理挙動のデバッグ方法として、
各翼で計算された力やモーメントを、3D空間上に矢印として可視化
する仕組みを実装しました。

このデバッグ表示により、
挙動に違和感がある場合でも、  
「どの翼の」「どの力・モーメントが」  
原因になっているのかを即座に切り分けることができ、
物理挙動の調整や修正を効率的に行えるようになりました。

このように、物理挙動を可視化しながら確認できる環境を用意することで、
実装だけでなく調整や仕様変更にも対応しやすい構成になっています。

#### 3.1.7 挙動実装を通じて見えたこと
当初は物理ベースの挙動が完成度向上につながると考え、
実装に挑戦しました。  
開発当初は、
物理的な正確さによって
見た目のリアリティも大きく向上すると想定していました。  
しかし実装を進める中で、
物理的な正確さと視覚的な変化は必ずしも比例せず、
見た目の変化に対して調整やデバッグの負担が大きくなる場面も多いことが分かりました。  
本作ではその経験を通じて、
「どこを物理として扱い、どこを割り切るか」
という設計判断の重要性を学びました。

### 3.2 海の描画実装
#### 3.2.1 実装の全体構成
海の反射は、以下の流れで実装しています。  
- 反射用カメラの作成  
- メインカメラを海面で鏡映した位置・向きに変換  
- 反射用カメラでシーンを描画し、レンダーテクスチャに出力  
- そのテクスチャを海モデルに貼り付けて描画
- 法線マップによるUV歪みとスクロールで波を表現

この構成により、
視点や機体の移動に応じて自然に変化する水面反射を実現しています。

#### 3.2.2 描画時の問題
反射用カメラを単純に鏡映した場合、
- 本来映らないはずの水面下のオブジェクトが反射に映る
- 逆に、映したいオブジェクトがクリップされる  

という描画になってしまいます。 

<div style="display: flex; gap: 16px;">
  <img src="スクリーンショット (8)-1.png" width="50%">
  <img src="スクリーンショット (10)-1.png" width="50%">
</div>
これは図のように近クリップ面が海面と一致しないため起こっています。

#### 3.2.3 描画時の問題の解決策

そこで、近平面波つかわず、シェーダー側で海面より下にあるかどうかを判定して描画を止める方法をとりました。

<div style="display: flex; gap: 16px;">
  <img src="スクリーンショット (4)-1.png" width="50%">
  <img src="スクリーンショット (5)-1.png" width="50%">
</div>
まず、海面を 1 枚の平面 として考えます。
（海面であるため、無限に続く平面として扱います。）

この平面より下にあるかどうかを判定する方法を考えます。
平面より 上側か下側か を判定するために、
平面が持つ 法線ベクトル を利用します。  
もし判定している点が海面上にある場合、
判定したい点と平面上の任意の点を結ぶベクトルは、
平面の法線ベクトルと 90 度 の角度になります。  
この性質を利用し、
判定したい点と平面上の点を結ぶベクトルと、
平面の法線ベクトルとの 内積 を計算します。  
この内積が 負 になる場合、
点は法線とは逆方向、つまり 平面より下側 にあると判定できます。  
本作では、
内積が負になる（海面より下にある）ピクセルは描画しない
という処理を行うことで、
反射描画時に海面下のオブジェクトが映り込まないようにしています。

### 3.3 処理負荷の問題
今回のゲームでは、1000個以上のオブジェクトを描画しています。
さらに海の表現では、反射用にシーンをもう一度描画しているため、そのままだと処理が重くなります。

ただし、使用しているモデルはローポリゴンなので、GPUの描画負荷自体はそこまで高くありませんでした。
そこで原因を調べたところ、ボトルネックはGPUではなく、CPU側で大量のドローコール（Draw呼び出し）をしていることだと分かりました。

この問題に対しては、対策としてインスタンス描画を導入しました。
同じモデルを1個ずつ描画するのではなく、複数個分の情報（行列など）をまとめて送って、1回のDrawでまとめて描画する方式です。
これにより、CPU側の呼び出し回数を抑え、描画処理を軽量化しています。